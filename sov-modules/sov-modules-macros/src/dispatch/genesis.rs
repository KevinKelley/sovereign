use syn::DataStruct;
use syn::DeriveInput;
use syn::TypeGenerics;

use super::MacroHelper;
use super::StructNamedField;

/*

// This code will be generated by a macro
impl<C: Context> Genesis for Runtime<C> {
    type Context = C;

    fn genesis() -> Result<C::Storage, Error> {
        let storage = C::Storage::default();

        let mut election = Election::<C>::new(storage.clone());
        election.genesis()?;

        let mut value_adder = ValueSetter::<C>::new(storage.clone());
        value_adder.genesis()?;

        Ok(storage)
    }
}
 */

pub(crate) struct GenesisMacro {
    helper: MacroHelper,
}

impl GenesisMacro {
    pub(crate) fn new(name: &'static str) -> Self {
        Self {
            helper: MacroHelper::new(name),
        }
    }

    pub(crate) fn derive_genesis(
        &self,
        input: DeriveInput,
    ) -> Result<proc_macro::TokenStream, syn::Error> {
        let DeriveInput {
            data,
            ident,
            generics,
            ..
        } = input;

        let (impl_generics, type_generics, _) = generics.split_for_impl();

        let fields = self.helper.get_fields_from_struct(&data)?;
        let genesis_fn_body = Self::make_genesis_fn_body(type_generics.clone(), &fields);

        Ok(quote::quote! {
            impl #impl_generics sov_modules_api::Genesis for #ident #type_generics {

                type Context = C;

                fn genesis() -> core::result::Result<C::Storage, sov_modules_api::Error> {
                    let storage = C::Storage::default();
                    #(#genesis_fn_body)*
                    Ok(storage)
                }

            }
        }
        .into())
    }

    fn make_genesis_fn_body(
        type_generics: TypeGenerics,
        fields: &[StructNamedField],
    ) -> Vec<proc_macro2::TokenStream> {
        fields
            .iter()
            .map(|field| {
                let ident = &field.ident;
                let ty = &field.ty;

                 quote::quote! {
                    let mut #ident = <#ty as sov_modules_api::ModuleInfo #type_generics>::new(storage.clone());
                    #ident.genesis()?;
                }
            })
            .collect()
    }
}
